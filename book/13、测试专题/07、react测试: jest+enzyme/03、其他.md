## 其他

目录
- [DOM交互测试：enzyme](#enzyme)
    - [渲染方式](#渲染方式)
    - [常用函数](#常用函数)
    
- [快照测试: snapshot](#快照测试)
    - [react-test-renderer](#react-test-renderer)
    - [enzyme-to-json](#enzyme-to-json)
    
- 异步action测试: redux-mock-store

- 关于mock
    

### enzyme
#### 渲染方式
enzyme有3种渲染方式：`render、mount、shallow`，先了解下区别。

**render**: render采用的是第三方库`Cheerio`的渲染，渲染结果是普通的html结构，对于snapshot使用render比较合适。

**shallow和mount**: 
shallow和mount对组件的渲染结果不是html的dom树，而是react树，如果你chrome装了react devtool插件，
他的渲染结果就是react devtool tab下查看的组件结构，而render函数的结果是element tab下查看的结果。

这些只是渲染结果上的差别，更大的差别是shallow和mount的结果是个被封装的 `ReactWrapper`，
可以进行多种操作，譬如find()、parents()、children()等选择器进行元素查找；
state()、props()进行数据查找，setState()、setprops()操作数据；
simulate()模拟事件触发。

**使用推荐**:
shallow只渲染当前组件，只能能对当前组件做断言；
mount会渲染当前组件以及所有子组件，对所有子组件也可以做上述操作。
一般交互测试都会关心到子组件，我使用的都是mount。
但是mount耗时更长，内存啥的也都占用的更多，如果没必要操作和断言子组件，可以使用shallow。

**三种渲染方式速度对比**：
```jsx harmony
describe('shallow vs render vs mount', function () {
    it('测试 shallow 500次', () => {
        for (let i = 0; i < 500; i++) {
            const app = shallow(<Example/>);
            app.find('button').text()
        }
    });

    it('测试render500次', () => {
        for (let i = 0; i < 500; i++) {
            const app = render(<Example/>);
            app.find('button').text()
        }
    });

    it('测试mount500次', () => {
        for (let i = 0; i < 500; i++) {
            const app = mount(<Example/>);
            app.find('button').text()
        }
    })
});
```
结果如下：                           
![test-result](https://img-blog.csdnimg.cn/20181107184558632.png)

#### 常用函数
- simulate(event, mock)：用来模拟事件触发，event为事件名称，mock为一个event object；
- instance()：返回测试组件的实例；
- find(selector)：根据选择器查找节点，selector可以是CSS中的选择器，也可以是组件的构造函数，以及组件的display name等；
- at(index)：返回一个渲染过的对象；
- get(index)：返回一个react node，要测试它，需要重新渲染；
- contains(nodeOrNodes)：当前对象是否包含参数重点 node，参数类型为react对象或对象数组；
- text()：返回当前组件的文本内容；
- html()： 返回当前组件的HTML代码形式；
- props()：返回根组件的所有属性；
- prop(key)：返回根组件的指定属性；
- state()：返回根组件的状态；
- setState(nextState)：设置根组件的状态；
- setProps(nextProps)：设置根组件的属性；




### 快照测试
只要想确保UI不会意外更改，快照测试是非常有用的工具。
在测试React组件时，可以使用测试渲染器快速生成React树的可序列化值，而不是渲染需要构建整个应用程序的图形UI。                 

下面做一个简单的Link组件的示例测试：                        
对于快照测试， 目前主要有两套生成快照库： `react-test-renderer、enzyme-to-json`                      

官方实例使用的是 `react-test-renderer`, 这里我们先通过官方实例入手                           

#### react-test-renderer                      
src/pages/Test/Link.jsx                                             
```jsx harmony
import React, {PureComponent} from 'react';
import PropTypes from 'prop-types';

const STATUS = {
  HOVERED: 'hovered',
  NORMAL: 'normal',
};

class Link extends PureComponent {
  static propTypes = {
    page: PropTypes.string.isRequired,
    children: PropTypes.oneOfType([
      PropTypes.element,
      PropTypes.string,
    ]).isRequired,
  };

  constructor(props) {
    super(props);

    this.state = {
      className: STATUS.NORMAL
    }
  }

  onMouseEnter = () => {
    this.setState({
      className: STATUS.HOVERED
    })
  };

  onMouseLeave = () => {
    this.setState({
      className: STATUS.NORMAL
    })
  };

  render() {
    const {className} = this.state;
    const { page, children } = this.props;
    return (
        <a
            className={className}
            href={page || '#'}
            onMouseEnter={this.onMouseEnter}
            onMouseLeave={this.onMouseLeave}
        >
          {children}
        </a>
    );
  }
}
export default Link;
```

src/pages/Test/__test__/Link.test.js                        
```jsx harmony
/*快照测试*/
import React from 'react';
// import toJson from 'enzyme-to-json';
import render from 'react-test-renderer';
import ALink from '../Link';

describe('Link', () => {
  it('正确的快照', function () {
    const tree = render.create(<ALink page="http://www.facebook.com">facebook</ALink>).toJSON();
    expect(tree).toMatchSnapshot();
  });

  it('这个是正确的快照更改', function () {
    const tree = render.create(<ALink page="http://www.yanleweb.com">yanlelele</ALink>).toJSON();
    expect(tree).toMatchSnapshot();
  });

  it('这种时候，快照就要报错了', function () {
    const user = {
      createAt: new Date(),
      id: Math.floor(Math.random() * 20),
      name: 'yanle',
    };
    expect(user).toMatchSnapshot({
      createAt: expect.any(Date),
      id: expect.any(Number),
    });
  });
});
```
如果我们希望更新快照： `yarn test --updateSnapshot` 或者 `yarn test -u`;

说明： 每次运行的时候， 每一个用例就会如果实现了快照， 就会产生一个快照文件 `src/pages/Test/__test__/__snapshots__/Link.test.js.snap`
内容如下：
```
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Link 正确的快照 1`] = `
<a
  className="normal"
  href="http://www.facebook.com"
  onMouseEnter={[Function]}
  onMouseLeave={[Function]}
>
  facebook
</a>
`;

exports[`Link 这个是正确的快照更改 1`] = `
<a
  className="normal"
  href="http://www.yanleweb.com"
  onMouseEnter={[Function]}
  onMouseLeave={[Function]}
>
  yanlelele
</a>
`;

exports[`Link 这种时候，快照就要报错了 1`] = `
Object {
  "createAt": Any<Date>,
  "id": Any<Number>,
  "name": "yanle",
}
`;
```
也就是输出快照的内容， 如果第二次运行测试用例， 因为某一些入参原因， 或者其他原因， 生成的快照与之前的不一样， 说明就是有问题的， 测试不会通过。
通过这种方式来对两次内容做比较。 


#### enzyme-to-json
通过enzyme-to-json 生成的快照， 用例文件写法如下：
```jsx harmony
/*快照测试*/
import React from 'react';
import {render} from 'enzyme';
import toJson from 'enzyme-to-json';
import ALink from '../Link';

describe('Link', () => {
  it('正确的快照', function () {
    const tree = render(<ALink page="http://www.facebook.com">facebook</ALink>);
    expect(toJson(tree)).toMatchSnapshot();
  });

  it('这个是正确的快照更改', function () {
    const tree = render(<ALink page="http://www.yanleweb.com">yanlelele</ALink>);
    expect(toJson(tree)).toMatchSnapshot();
  });

  it('这种时候，快照就要报错了', function () {
    const user = {
      createAt: new Date(),
      id: Math.floor(Math.random() * 20),
      name: 'yanle',
    };
    expect(user).toMatchSnapshot({
      createAt: expect.any(Date),
      id: expect.any(Number),
    });
  });
});
```

生成快照文件如下：
```
// Jest Snapshot v1, https://goo.gl/fbAQLP

exports[`Link 正确的快照 1`] = `
<a
  class="normal"
  href="http://www.facebook.com"
>
  facebook
</a>
`;

exports[`Link 这个是正确的快照更改 1`] = `
<a
  class="normal"
  href="http://www.yanleweb.com"
>
  yanlelele
</a>
`;

exports[`Link 这种时候，快照就要报错了 1`] = `
Object {
  "createAt": Any<Date>,
  "id": Any<Number>,
  "name": "yanle",
}
`;
```

明显发现， 少了方法比较而已， 其他几乎是一样的。
