## 创建数据流

### 同步数据流

#### create
函数签名: create(subscribe: function)                   
使用给定的订阅函数来创建 observable 。                   

示例 1: 发出多个值的 observable
```typescript
import { Observable } from 'rxjs';

const { create } = Observable;

// 创建在订阅函数中发出 'Hello' 和 'World' 的 observable 。
const hello$: Observable<string> = create(observer => {
  observer.next('hello');
  observer.next('world');
});

hello$.subscribe(value => console.log(value));
```

示例 2: 基于定时器发出偶数的 observable
```typescript
import { Observable } from 'rxjs';

const { create } = Observable;

const evenNumbers$: Observable<number> = create(observer => {
  let time = 0;
  const handleInterval = setInterval(() => {
    if (time % 2 === 0) {
      observer.next(time);
    }
    time++;
  }, 500);

  // 用于取消订阅
  return () => clearInterval(handleInterval);
});

const subscribe$ = evenNumbers$.subscribe(value => console.log(value));

setTimeout(() => {
  subscribe$.unsubscribe();
}, 5000);
```


#### of
列举数据                            
函数签名： `function of<T>(...args: T[]): Observable<T>`                     

demo1: 发出数字序列
```typescript
/**
 * 发出数字序列
 */
import { Observable, of } from 'rxjs';
const source$: Observable<number> = of(1, 2, 3, 4, 5, 6, 7);
source$.subscribe(value => console.log(value));
```

demo2: 示例 2: 发出对象、数组和函数
```typescript
import { of } from 'rxjs';

const source$ = of({name: 'yanle'}, [1,2,3,4,5,6], function(){console.log('hello rxjs')});

source$.subscribe(value => console.log(value));
```

#### range
指定范围                            
函数签名： `function range(start: number = 0, count?: number, scheduler?: SchedulerLike): Observable<number>`

```typescript
/**
 * 依次发出给定区间内的数字。
 */
import { range } from 'rxjs';

const source$ = range(1, 10);
source$.subscribe(value => console.log(value));
```


#### empty
立即完成的observable
```typescript
/**
 * 立即完成
 */
import { empty } from 'rxjs';

const source$ = empty();
source$.subscribe(
  () => console.log('next'),
  null,
  () => console.log('complete'),
);
```

#### throwError
throwError产⽣的Observable对象也是什么都不做，直接出错，抛出的错误就是throw的参数，下⾯是使⽤throw的⽰例代码
```typescript
/**
 * 示例 1: 在订阅上抛出错误
 */
import { throwError } from 'rxjs';

const source$ = throwError('this is an error!');
source$.subscribe(
  value => console.log(value),
  err => console.log('error: ', err),
  () => console.log('complete!'),
);
```


### 异步数据流

#### 定时产生数据 interval和timer

`interval` 基于给定时间间隔发出数字序列
```
import { interval } from 'rxjs';

const source$ = interval(1000);
source$.subscribe(value=>console.log(value));
```

`timer` 给定持续时间后，再按照指定间隔时间依次发出数字。
```typescript
import { timer } from 'rxjs';

// 如果只有一个参数， 那么发出 0 之后， 就立马结束了
const source$ = timer(1000);
source$.subscribe(value => console.log('source$: ', value));

// timer 接收第⼆个参数，它决定了发出序列值的频率，在本例中我们在1秒发出第⼀个值，
// 然后每0.5秒发出序列值
// 所以结果是 timer 1秒后发出值，然后每0.5秒发出值
const source2$ = timer(1000, 500);
source2$.subscribe(value => console.log('source2$: ', value));
```


#### from
将数组、promise 或迭代器转换成observable

```typescript
import { from } from 'rxjs';

// 数组转为 observable
const source$ = from([1,2,3,4,5]);
source$.subscribe(value => console.log(value));

// promise 转为 observable
const source2$ = from(
  new Promise(resolve => resolve('hello world!'))
);
source2$.subscribe(value=>console.log(value));

// 集合转为observable
const map = new Map();
map.set(1, 'hi');
map.set(2, 'bye');

const source3$ = from(map);
source3$.subscribe(value => console.log(value));
// 输出： [1, Hi'], [2, Bye]

// 字符串转为 observable
const source4$ = from('hello world');
source4$.subscribe(value => console.log(value));
// 输出: 'H','e','l','l','o',' ','W','o','r','l','d'
```

#### fromPromise
如果from的参数是Promise对象，那么这个Promise成功结束，from产⽣的Observable对象就会吐出Promise成功的结果，并且⽴刻结束

实际上这个地方 formPromise 可以换做 from , 效果是一样的
```typescript
import { of } from 'rxjs';
import { catchError, mergeMap } from 'rxjs/operators';
import { fromPromise } from 'rxjs/internal-compatibility';

const myPromise = willReject => new Promise((resolve, reject) => {
  if (willReject) {
    reject('rejected!');
  } else {
    resolve('resolved!');
  }
});

// 先发出true , 然后在发出 false
const source$ = of(false, true);
const example$ = source$.pipe(
  // 这个地方， 如果先发射出true, 那么 promise 就会走到rejected 里面
  // 这个时候实际上状态已经停止了
  mergeMap(value => fromPromise(myPromise(value))),
  catchError(
    error => of(`Error： ${error}`), // 如果出现了, 那么重新返回一个 observable
  ),
);
example$.subscribe(
  value => console.log('next: ', value),
  err => console.log('err: ', err),
  () => console.log('complete'),
);
```


#### fromEvent
如果从事⽹页开发，fromEvent是最可能会被⽤到的操作符，因为⽹页应⽤总是要获取⽤户在⽹页中的操作事件，
⽽fromEvent最常见的⽤法就是把DOM中的事件转化为Observable对象中的数据

fromEvent的第⼀个参数是⼀个事件源，在浏览器中，最常见的事件源就是特定的DOM元素，
第⼆个参数是事件的名称，对应DOM事件就是click、mousemove这样的字符串。
```typescript
import { fromEvent } from 'rxjs';
import { map } from 'rxjs/operators';

const source$ = fromEvent(document, 'click');
const resource$ = source$.pipe(
  map(event => `Event time: ${event.timeStamp}`)
);

resource$.subscribe(value => console.log(value));
```

fromEvent除了可以从DOM中获得数据，还可以从Node.js的events中获得数据，下⾯是⼀段⽰例代码：
```typescript
import * as EventEmitter from 'events';
import { fromEvent } from 'rxjs';

const emitter = new EventEmitter();
const source$ = fromEvent(emitter, 'message');
source$.subscribe(value => console.log(value));

emitter.emit('message', 1);
emitter.emit('message', 2);
emitter.emit('other', 'oops');
emitter.emit('message', 3);
```



