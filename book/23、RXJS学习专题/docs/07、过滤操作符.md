## 过滤操作符


## 过滤操作符的模式


### filter
没有啥好说的

示例1：基础示例                    
```typescript
import { range } from 'rxjs';
import { filter } from 'rxjs/operators';

const source$ = range(1, 5);
const even$ = source$.pipe(
  filter(x => x % 2 === 0),
);

even$.subscribe(value => console.log(value));
/*
结果：
2
4
* */
```



### first
`first(predicate: function, select: function)`                          

发出第⼀个值或第⼀个通过给定表达式的值。

first可以没有判定函数参数。
相当于找上游Observable吐出的第⼀个数据。

示例1：无参数                     
```typescript
const source = Rx.Observable.from([1, 2, 3, 4, 5]);
// 没有参数则发出第⼀个值
const example = source.first();
// 输出: "First value: 1"
const subscribe = example.subscribe(val => console.log(`Fi
rst value: ${val}`));
```

示例2：第⼀个通过 predicate 函数的值
```typescript
const source = Rx.Observable.from([1, 2, 3, 4, 5]);    // 发出通过测试的第⼀项
const example = source.first(num => num === 5);
// 输出: "First to pass test: 5"
const subscribe = example.subscribe(val =>
console.log(`First to pass test: ${val}`)
);
```

示例 3: 使⽤可选的 projection 函数
```typescript
const source = Rx.Observable.from([1, 2, 3, 4, 5]);
// 使⽤可选的 projection 函数
const example = source.first(
num => num % 2 === 0,
(result, index) => `First even: ${result} is at index: ${
index}`
);
// 输出: "First even: 2 at index: 1"
const subscribe = example.subscribe(val => console.log(val)
);
```

### last
last这个操作符做的事情和first正相反，找的是⼀个Observable中最后⼀个判定条件的数据.



### take
take就是“拿”，从上游Observable拿数据，拿够了就完结，⾄于怎么
算“拿够”，由take的参数来决定，take只⽀持⼀个参数count，也就是限定拿
上游Observable的数据数量。

```typescript
import 'rxjs/add/observable/interval';
import 'rxjs/add/operator/take';
const source$ = Observable.interval(1000);
const last$ = source$.take(3);
```
虽然source$是⼀个永不完结的数据流，但是take的参数3限定了它只拿
3个，三秒之后，take产⽣的last$就完成任务，`⽴刻完结`

### takeLast
take相当于⼀个可以获取多个数据的first，那么takeLast相当于⼀个可
以获取多个数据的last。和last⼀样，takeLast只有在上游数据完结的时候才
能决定“最后”的数据是哪些，在吐出这些数据之后⽴刻完结。

```typescript
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/takeLast';
const source$ = Observable.of(3, 1, 4, 1, 5, 9);
const last3$ = source$.takeLast(3);
```
last3$会吐出source$最后吐出的三个数1、5、9，然后完结

### takeWhile
takeWhile接受⼀个判定函数作为参数，这个判定函数有两个
参数，分别代表上游的数据和对应的序号，takeWhile会吐出上游数据，直
到判定函数返回false，只要遇到第⼀个判定函数返回false的情况，
takeWhile产⽣的Observable就完结。



