## 过滤操作符


## 过滤操作符的模式


### filter
没有啥好说的

示例1：基础示例                    
```typescript
import { range } from 'rxjs';
import { filter } from 'rxjs/operators';

const source$ = range(1, 5);
const even$ = source$.pipe(
  filter(x => x % 2 === 0),
);

even$.subscribe(value => console.log(value));
/*
结果：
2
4
* */
```



### first
`first(predicate: function, select: function)`                          

发出第⼀个值或第⼀个通过给定表达式的值。

first可以没有判定函数参数。
相当于找上游Observable吐出的第⼀个数据。

示例1：无参数                     
```typescript
const source = Rx.Observable.from([1, 2, 3, 4, 5]);
// 没有参数则发出第⼀个值
const example = source.first();
// 输出: "First value: 1"
const subscribe = example.subscribe(val => console.log(`Fi
rst value: ${val}`));
```

示例2：第⼀个通过 predicate 函数的值
```typescript
const source = Rx.Observable.from([1, 2, 3, 4, 5]);    // 发出通过测试的第⼀项
const example = source.first(num => num === 5);
// 输出: "First to pass test: 5"
const subscribe = example.subscribe(val =>
console.log(`First to pass test: ${val}`)
);
```

示例 3: 使⽤可选的 projection 函数
```typescript
const source = Rx.Observable.from([1, 2, 3, 4, 5]);
// 使⽤可选的 projection 函数
const example = source.first(
num => num % 2 === 0,
(result, index) => `First even: ${result} is at index: ${
index}`
);
// 输出: "First even: 2 at index: 1"
const subscribe = example.subscribe(val => console.log(val)
);
```

### last
last这个操作符做的事情和first正相反，找的是⼀个Observable中最后⼀个判定条件的数据.



### take
take就是“拿”，从上游Observable拿数据，拿够了就完结，⾄于怎么
算“拿够”，由take的参数来决定，take只⽀持⼀个参数count，也就是限定拿
上游Observable的数据数量。

```typescript
import 'rxjs/add/observable/interval';
import 'rxjs/add/operator/take';
const source$ = Observable.interval(1000);
const last$ = source$.take(3);
```
虽然source$是⼀个永不完结的数据流，但是take的参数3限定了它只拿
3个，三秒之后，take产⽣的last$就完成任务，`⽴刻完结`

### takeLast
take相当于⼀个可以获取多个数据的first，那么takeLast相当于⼀个可
以获取多个数据的last。和last⼀样，takeLast只有在上游数据完结的时候才
能决定“最后”的数据是哪些，在吐出这些数据之后⽴刻完结。

```typescript
import 'rxjs/add/observable/of';
import 'rxjs/add/operator/takeLast';
const source$ = Observable.of(3, 1, 4, 1, 5, 9);
const last3$ = source$.takeLast(3);
```
last3$会吐出source$最后吐出的三个数1、5、9，然后完结

### takeWhile
takeWhile接受⼀个判定函数作为参数，这个判定函数有两个
参数，分别代表上游的数据和对应的序号，takeWhile会吐出上游数据，直
到判定函数返回false，只要遇到第⼀个判定函数返回false的情况，
takeWhile产⽣的Observable就完结。


### takeUntil
使⽤takeUntil，上游的数据直接转⼿给下游，直到（Until）参数
notifier吐出⼀个数据或者完结，这个notifier就像⼀个⽔龙头开关，控制着
takeUntil产⽣的Observable对象，⼀开始这个⽔龙头开关是打开状态，上游
的数据像⽔⼀样直接流到下游，但是notifier只要⼀有动静，⽔龙头开关⽴
刻关闭，上游通往下游的通道也就关闭了。

```typescript
import 'rxjs/add/observable/interval';
import 'rxjs/add/observable/timer';
import 'rxjs/add/operator/takeUntil';

const source$ = Observable.interval(1000);
const notifier$ = Observable.timer(2500);
const takeUntil$ = source$.takeUntil(notifier$);
```
在上⾯的代码中，notifier$的作⽤就是在未来给source$⼀个“通知”，切
断⽔龙头的开关，所以使⽤timer这个操作符，在2.5秒之后动⼿。选择2.5
秒⽽不是3秒是故意错开时间。

注意，作为takeUntil的notifier参数如果在吐出数据或者完结之前抛出
了错误，那takeUntil也会把这个错误抛给下游，从⽽关闭了上下游之间的
通道，下⾯是⽰例代码：
```typescript
const source$ = Observable.interval(1000);
const notifier$ = Observable.throw('custom error');
const takeUntil$ = source$.takeUntil(notifier$);
```

示例1：                            
```typescript
let clickCount = 0;
const event$ = Rx.Observable.fromEvent(document.querySelector('#clickMe'), 'click');
const countDown$ = Rx.Observable.timer(5000);
const filtered$ = event$.takeUntil(countDown$);
const showEnd = () => {
document.querySelector('#end').innerText = '时间结束';
};
const updateCount = () => {
document.querySelector('#text').innerText = ++clickCount
};
countDown$.subscribe(showEnd);
filtered$.subscribe(updateCount);
```
在这个例⼦中，countDown$扮演两个⾓⾊，⾸先，它是⼀个
Observable对象，有⾃⼰的Observer名为showEnd，当5秒钟之后吐出数据
时，showEnd被调⽤，在⽹页中显⽰“时间结束”；其次，countDown$的第
⼆个⾓⾊也是takeUntil的参数，在5秒钟时，完结了filtered$。



### skip
skip接受⼀个count参数，会默默忽略上游Observable吐出的前count个
数据，然后，从第count+1个数据开始，就和上游Observable保持⼀致了，
上游Observable吐出什么数据，skip产⽣的Observable就吐出什么数据，上
游Observable完结，skip产⽣的Observable跟着完结。当然，如果上游吐出
的数据不够count个，那skip产⽣的Observable就会在上游Observable完结的
时候⽴刻完结


### skipWhile

直接上代码
```typescript
const source$ = Observable.interval(1000);
const skipWhile$ = source$.skipWhile(value => value % 2 === 0);
```
其中，skipWhile的参数可以判断⼀个数据是否为偶数，所以skipWhile
会跳过数据流前⾯的偶数数据，注意，只是跳过数据流前⾯的偶数数据，
⽽不是跳过数据流中所有的偶数数据。









