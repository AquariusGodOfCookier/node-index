## 合并数据流

在RxJS的世界中，为了满⾜复杂的需求，往往需要把不同来源的数据汇聚在⼀起，
把来⾃多个Observable对象的数据合并到⼀个Observable对象中，这就是本章介绍的内容。

功能需求 | 使用的操作符
:- | :-
把多个数据流以收尾相连接的方式合并 | concat / concatAll
把多个数据流中数据以先到先得的方式合并 | merge / mergeAll
把过个数据流中数据以一一对应的方式合并 | zip / zipAll
持续合并多个数据流中最新产生的数据 | combineLatest / combineAll / withLatestFrom
从多个数据流中选择第一个产生内容的数据流 | race
在数据流前面添加一个指定的数据 | startWith
只获取多个数据流最后产生的那个数据 | forkJoin
从告诫数据流中切换数据源 | switch / exhaust

### 合并类操作符

#### concat
按照顺序，前⼀个 observable 完成了再订阅下⼀个 observable 并发出值.                      

- 你可以把 concat 想象成 ATM 机前的⻓队，下⼀次交易 (subscription)不能在前⼀个交易完成前开始！
- 如果产⽣值的顺序不是⾸要考虑的，那么试试⽤ merge 来代替！

```typescript
/**
 * 最基本的使用
 *
 * 下面这种方式是作为 静态方法的实现，
 * 在RXJS5 版本的时候， 是可以通过实例方法实现concat的， 但是到了6 版本就取消了
 * 实例方法就是这样的 sourceOne$.concat(sourceTwo$); 这种方式在6版本取消了
 * 六版本只允许静态方法的方式创建合并
 */
import { concat, interval, of } from 'rxjs';
import { delay } from 'rxjs/operators';

const sourceOne$ = of(1, 2, 3);
const sourceTwo$ = of(4, 5, 6);
const example$ = concat(sourceOne$, sourceTwo$);

example$.subscribe(value => console.log(value));


/**
 * 使⽤延迟的 source observable 进⾏ concat
 */
// 延迟3秒发出
const sourceThree$ = sourceOne$.pipe(delay(3000));
// sourceTwo$ 要等待 sourceOne$ 完成之后才能订阅
const example2$ = concat(sourceThree$, sourceTwo$);
example2$.subscribe(value => console.log('Example: Delayed source one : ', value));


/**
 * 使⽤不完成的 source observable 进⾏ concat
 */
const source3$ = concat(
  interval(1000),
  of('this', 'never', 'runs')
);
source3$.subscribe(value => console.log('Example: Source never completes, second observable never runs: ', value));
```

#### merge

- merge会第⼀时间订阅所有的上游Observable，然后对上游的数据采取“先到先得”的策略，
任何⼀个Observable只要有数据推下来，就⽴刻转给下游Observable对象。
- 如果某个上游Observable对象不能完结，并不影响其他Observable对象的数据传给merge的下游。
- merge只有在所有的上游Observable都完结的时候，才会完结⾃⼰产⽣的Observable对象
- 如果产⽣值的顺序是⾸要考虑的，那么试试⽤ concat 来代替！


基本使用:                       
```typescript
/**
 * 基本使用
 */
import { interval, merge } from 'rxjs';
import { mapTo } from 'rxjs/operators';

const first$ = interval(2500);
const second$ = interval(2000);
const third$ = interval(1500);
const fourth$ = interval(1000);

// 从一个observable中发出输出值
const example$ = merge(
  first$.pipe(mapTo('first!')),
  second$.pipe(mapTo('second!')),
  third$.pipe(mapTo('third!')),
  fourth$.pipe(mapTo('fourth!')),
);

example$.subscribe(value => console.log(value));
```

merge可以有⼀个可选参数concurrent，⽤于指定可以同时合并的Observable对象个数

假设现在有3个Observable对象，⽽concurrent参数的值为2，如下⾯的              
代码所⽰：
```typescript
import { merge, timer } from 'rxjs';
import { map } from 'rxjs/operators';

const source1$ = timer(0, 1000).pipe(map(x => x + 'A'));
const source2$ = timer(500, 1000).pipe(map(x => x + 'B'));
const source3$ = timer(1000, 1000).pipe(map(x => x + 'C'));

// source3$中的数据永远不会获得进⼊merged$的机会，因为 merge最后⼀个参数是2，也就限定了同时只能同步合并两个Observable对象的数据，
const merged$ = merge(source1$, source2$, source3$, 2);

merged$.subscribe(value => console.log(value));
```


**使用场景**
我们知道fromEvent可以从⽹页中获取事件，只可惜，fromEvent⼀次
只能从⼀个DOM元素获取⼀种类型的事件。⽐如，我们关⼼某个元素的
click事件，同时也关⼼这个元素上的touchend事件，因为在移动设备上
touchend事件出现得⽐click更早，这两个事件的处理是⼀模⼀样的，但是
fromEvent不能同时获得两个事件的数据流，这时候就要借助merge的⼒量
了，代码如下：
```typescript
import { fromEvent, merge } from 'rxjs';

const click$ = fromEvent(document, 'click');
const touchend$ = fromEvent(document, 'touchend');
const merged$ = merge(click$, touchend$);

merged$.subscribe(value => console.log(value));
```



