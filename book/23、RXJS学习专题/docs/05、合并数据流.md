## 合并数据流

在RxJS的世界中，为了满⾜复杂的需求，往往需要把不同来源的数据汇聚在⼀起，
把来⾃多个Observable对象的数据合并到⼀个Observable对象中，这就是本章介绍的内容。

功能需求 | 使用的操作符
:- | :-
把多个数据流以收尾相连接的方式合并 | concat / concatAll
把多个数据流中数据以先到先得的方式合并 | merge / mergeAll
把过个数据流中数据以一一对应的方式合并 | zip / zipAll
持续合并多个数据流中最新产生的数据 | combineLatest / combineAll / withLatestFrom
从多个数据流中选择第一个产生内容的数据流 | race
在数据流前面添加一个指定的数据 | startWith
只获取多个数据流最后产生的那个数据 | forkJoin
从告诫数据流中切换数据源 | switch / exhaust

### 合并类操作符

#### concat
按照顺序，前⼀个 observable 完成了再订阅下⼀个 observable 并发出值.                      

- 你可以把 concat 想象成 ATM 机前的⻓队，下⼀次交易 (subscription)不能在前⼀个交易完成前开始！
- 此操作符可以既有静态⽅法，⼜有实例⽅法！
- 如果产⽣值的顺序不是⾸要考虑的，那么试试⽤ merge 来代替！

```typescript
/**
 * 最基本的使用
 *
 * 下面这种方式是作为 静态方法的实现，
 * 在RXJS5 版本的时候， 是可以通过实例方法实现concat的， 但是到了6 版本就取消了
 * 实例方法就是这样的 sourceOne$.concat(sourceTwo$); 这种方式在6版本取消了
 * 六版本只允许静态方法的方式创建合并
 */
import { concat, interval, of } from 'rxjs';
import { delay } from 'rxjs/operators';

const sourceOne$ = of(1, 2, 3);
const sourceTwo$ = of(4, 5, 6);
const example$ = concat(sourceOne$, sourceTwo$);

example$.subscribe(value => console.log(value));


/**
 * 使⽤延迟的 source observable 进⾏ concat
 */
// 延迟3秒发出
const sourceThree$ = sourceOne$.pipe(delay(3000));
// sourceTwo$ 要等待 sourceOne$ 完成之后才能订阅
const example2$ = concat(sourceThree$, sourceTwo$);
example2$.subscribe(value => console.log('Example: Delayed source one : ', value));


/**
 * 使⽤不完成的 source observable 进⾏ concat
 */
const source3$ = concat(
  interval(1000),
  of('this', 'never', 'runs')
);
source3$.subscribe(value => console.log('Example: Source never completes, second observable never runs: ', value));
```
