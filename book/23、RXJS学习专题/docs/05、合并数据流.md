## 合并数据流

在RxJS的世界中，为了满⾜复杂的需求，往往需要把不同来源的数据汇聚在⼀起，
把来⾃多个Observable对象的数据合并到⼀个Observable对象中，这就是本章介绍的内容。

功能需求 | 使用的操作符
:- | :-
把多个数据流以收尾相连接的方式合并 | concat / concatAll
把多个数据流中数据以先到先得的方式合并 | merge / mergeAll
把过个数据流中数据以一一对应的方式合并 | zip / zipAll
持续合并多个数据流中最新产生的数据 | combineLatest / combineAll / withLatestFrom
从多个数据流中选择第一个产生内容的数据流 | race
在数据流前面添加一个指定的数据 | startWith
只获取多个数据流最后产生的那个数据 | forkJoin
从告诫数据流中切换数据源 | switch / exhaust

### 合并类操作符

#### concat
按照顺序，前⼀个 observable 完成了再订阅下⼀个 observable 并发出值.                      

- 你可以把 concat 想象成 ATM 机前的⻓队，下⼀次交易 (subscription)不能在前⼀个交易完成前开始！
- 如果产⽣值的顺序不是⾸要考虑的，那么试试⽤ merge 来代替！

```typescript
/**
 * 最基本的使用
 *
 * 下面这种方式是作为 静态方法的实现，
 * 在RXJS5 版本的时候， 是可以通过实例方法实现concat的， 但是到了6 版本就取消了
 * 实例方法就是这样的 sourceOne$.concat(sourceTwo$); 这种方式在6版本取消了
 * 六版本只允许静态方法的方式创建合并
 */
import { concat, interval, of } from 'rxjs';
import { delay } from 'rxjs/operators';

const sourceOne$ = of(1, 2, 3);
const sourceTwo$ = of(4, 5, 6);
const example$ = concat(sourceOne$, sourceTwo$);

example$.subscribe(value => console.log(value));


/**
 * 使⽤延迟的 source observable 进⾏ concat
 */
// 延迟3秒发出
const sourceThree$ = sourceOne$.pipe(delay(3000));
// sourceTwo$ 要等待 sourceOne$ 完成之后才能订阅
const example2$ = concat(sourceThree$, sourceTwo$);
example2$.subscribe(value => console.log('Example: Delayed source one : ', value));


/**
 * 使⽤不完成的 source observable 进⾏ concat
 */
const source3$ = concat(
  interval(1000),
  of('this', 'never', 'runs')
);
source3$.subscribe(value => console.log('Example: Source never completes, second observable never runs: ', value));
```

#### merge

- merge会第⼀时间订阅所有的上游Observable，然后对上游的数据采取“先到先得”的策略，
任何⼀个Observable只要有数据推下来，就⽴刻转给下游Observable对象。
- 如果某个上游Observable对象不能完结，并不影响其他Observable对象的数据传给merge的下游。
- merge只有在所有的上游Observable都完结的时候，才会完结⾃⼰产⽣的Observable对象
- 如果产⽣值的顺序是⾸要考虑的，那么试试⽤ concat 来代替！


基本使用:                       
```typescript
/**
 * 基本使用
 */
import { interval, merge } from 'rxjs';
import { mapTo } from 'rxjs/operators';

const first$ = interval(2500);
const second$ = interval(2000);
const third$ = interval(1500);
const fourth$ = interval(1000);

// 从一个observable中发出输出值
const example$ = merge(
  first$.pipe(mapTo('first!')),
  second$.pipe(mapTo('second!')),
  third$.pipe(mapTo('third!')),
  fourth$.pipe(mapTo('fourth!')),
);

example$.subscribe(value => console.log(value));
```

merge可以有⼀个可选参数concurrent，⽤于指定可以同时合并的Observable对象个数

假设现在有3个Observable对象，⽽concurrent参数的值为2，如下⾯的              
代码所⽰：
```typescript
import { merge, timer } from 'rxjs';
import { map } from 'rxjs/operators';

const source1$ = timer(0, 1000).pipe(map(x => x + 'A'));
const source2$ = timer(500, 1000).pipe(map(x => x + 'B'));
const source3$ = timer(1000, 1000).pipe(map(x => x + 'C'));

// source3$中的数据永远不会获得进⼊merged$的机会，因为 merge最后⼀个参数是2，也就限定了同时只能同步合并两个Observable对象的数据，
const merged$ = merge(source1$, source2$, source3$, 2);

merged$.subscribe(value => console.log(value));
```


**使用场景**                            
我们知道fromEvent可以从⽹页中获取事件，只可惜，fromEvent⼀次
只能从⼀个DOM元素获取⼀种类型的事件。⽐如，我们关⼼某个元素的
click事件，同时也关⼼这个元素上的touchend事件，因为在移动设备上
touchend事件出现得⽐click更早，这两个事件的处理是⼀模⼀样的，但是
fromEvent不能同时获得两个事件的数据流，这时候就要借助merge的⼒量
了，代码如下：
```typescript
import { fromEvent, merge } from 'rxjs';

const click$ = fromEvent(document, 'click');
const touchend$ = fromEvent(document, 'touchend');
const merged$ = merge(click$, touchend$);

merged$.subscribe(value => console.log(value));
```

#### zip

拉链式组合                               

拉链合并两条链齿的关键，就是链齿必须⼀⼀
对应，这也是zip这个操作符的⼯作⽅式。zip就像是⼀个拉条，上游的
Observable对象就像是拉链的链齿，通过拉条合并，数据⼀定是⼀⼀对应的。

zip 操作符会订阅所有内部 observables，然后等待每个发出⼀个值。
⼀旦发⽣这种情况，将发出具有相应索引的所有值。
这会持续进⾏，直到⾄少⼀个内部 observable 完成。                      

demo0: 非常简单的一个例子
```typescript
import { of, zip } from 'rxjs';

const source1$ = of(1, 2, 3);
const source2$ = of('a', 'b', 'c');
const zipped$ = zip(source1$, source2$);

zipped$.subscribe(value => console.log(value));
```

demo1: 以交替的时间间隔对多个 observables 进⾏ zip          
```typescript
/**
 * 以交替的时间间隔对多个 observables 进⾏ zip
 */
import { of, zip } from 'rxjs';
import { delay } from 'rxjs/operators';

const sourceOne$ = of('hello');
const sourceTwo$ = of('world!');
const sourceThree$ = of('GoodBye');
const sourceFour$ = of('world!');

const example$ = zip(
  sourceOne$,
  sourceTwo$.pipe(delay(1000)),
  sourceThree$.pipe(delay(2000)),
  sourceFour$.pipe(delay(3000)),
);

example$.subscribe(value => console.log(value));
// [ 'hello', 'world!', 'GoodBye', 'world!' ]
```

demo2: 当⼀个 observable 完成时进⾏ zip
```typescript
/**
 * 当⼀个 observable 完成时进⾏ zip
 */
import { interval, zip } from 'rxjs';
import { take } from 'rxjs/operators';

const interval$ = interval(1000);
const example$ = zip(
  interval$,
  interval$.pipe(take(2))
);
example$.subscribe(value => console.log(value));
// [ 0, 0 ]
// [ 1, 1 ]
```



#### combineLatest
combineLatest合并数据流的⽅式是当任何⼀个上游Observable产⽣数据
时，从所有输⼊Observable对象中拿最后⼀次产⽣的数据（最新数据），
然后把这些数据组合起来传给下游。

combineLatest可能会反复使⽤上游产⽣的最新数据，只要上游不产⽣新的数据，那
combineLatest就会反复使⽤这个上游最后⼀次产⽣的数据

demo1:
```typescript
import { combineLatest, timer } from 'rxjs';

const source1$ = timer(500, 1000);
const source2$ = timer(1000, 1000);
const resource$ = combineLatest(source1$, source2$);

resource$.subscribe(value => console.log(value));
```
输出结果：           
```
[ 0, 0 ]
[ 1, 0 ]
[ 1, 1 ]
[ 2, 1 ]
[ 2, 2 ]
[ 3, 2 ]
```

每个数组中元素的个数和上游Observable数量相同，每个元素的下标和对应数
据源在combineLatest中的参数位置⼀致。

第⼀个数组元素来⾃于调⽤了
combineLatest的Observable对象，第⼆个元素来⾃于combineLatest的第⼀个参数；

![05-01](./image/05-01.png)                             


让source2$只吐出⼀个数据就完结，可以
看到combineLatest对单个上游Observable完结的处理，代码如下:               
```typescript
import { combineLatest, of, timer } from 'rxjs';

const source1$ = timer(500, 1000);
const source2$ = of('a');
const result$ = combineLatest(source1$, source2$);

result$.subscribe(value => console.log(value));
```
结果：             
```
[ 0, 'a' ]
[ 1, 'a' ]
[ 2, 'a' ]
[ 3, 'a' ]
......
```

上⾯的代码例⼦中，上游都有包含异步产⽣数据的Observable对象，
如果上游全部都是同步产⽣数据的Observable对象会怎样呢？结果可能会
和你想象的不⼤⼀样
```typescript
import { combineLatest, of } from 'rxjs';

const source1$ = of('a', 'b', 'c');
const source2$ = of(1, 2, 3);
const result$ = combineLatest(source1$, source2$);

result$.subscribe(value => console.log(value));
```
结果：             
```
[ 'c', 1 ]
[ 'c', 2 ]
[ 'c', 3 ]
```
这是由combineLatest的⼯作⽅式决定的。combineLatest会顺序订阅所
有上游的Observable对象，只有所有上游Observable对象都已经吐出数据
了，才会给下游传递所有上游“最新数据”组合的数据。


下⾯是合并三个of产⽣的Observable对象的代码:                
```typescript
import { combineLatest, of } from 'rxjs';

const source1$ = of('a', 'b', 'c');
const source2$ = of(1,2,3);
const source3$ = of('x', 'y');
const result$ = combineLatest(source1$, source2$, source3$);

result$.subscribe(value => console.log(value));
```
结果:             
```
[ 'c', 3, 'x' ]
[ 'c', 3, 'y' ]
```


**combineLatest: 1、定制下游数据**
如果`combineLatest`的输⼊只有`Observable`对象，那么传递给下游的数据
就是⼀个包含所有上游“最新数据”的数组，但是，有时候这样并不⽅便，
我们可能希望下游接收到的不是数组⽽是已经被真正“组合”过的数据。这
时候，可以利⽤`combineLatest`的⼀个可选参数`project`

combineLatest的最后⼀个参数可以是⼀个函数，这⾥我们称之为
project，project的作⽤是让combineLatest把所有上游的“最新数据”扔给下游
之前做⼀下组合处理。

project可以包含多个参数，每⼀个参数对应的是上游Observable的最新数据，project返回的结果就是combineLatest塞给下游的结果。                  
```typescript
import { combineLatest, timer } from 'rxjs';
import { map } from 'rxjs/operators';

const source1$ = timer(500, 1000);
const source2$ = timer(1000, 1000);
const project = (a, b) => `${a} and ${b}`;

const result$ = combineLatest(source1$, source2$, project);
result$.subscribe(value => console.log(value));

/* ==============================  map 操作符号的场景 - Start ============================== */
const result2$ = combineLatest(source1$, source2$)
  .pipe(map(arr => project(...arr)));
result2$.subscribe(value => console.log(value));  // 输出结果跟上面一模一样

/* ==============================  map 操作符号的场景 - End   ============================== */

```
结果：                 
```
0 and 0
1 and 0
1 and 1
2 and 1
2 and 2
3 and 2
3 and 3
......
```

**combineLatest: 2、多重依赖**
combineLatest产⽣的Observable对象数据依赖于上游的多个Observable
对象，如果上游的多个Observable对象又共同依赖于另⼀个Observable对
象，这就是多重（chong第2声）依赖问题

```typescript
import { combineLatest, timer } from 'rxjs';
import { map } from 'rxjs/operators';

const original$ = timer(0, 1000);
const source1$ = original$.pipe(map(x => x + ' a'));
const source2$ = original$.pipe(map(x => x + ' b'));
const result$ = combineLatest(source1$, source2$);

result$.subscribe(value => console.log(value));
```
看这段程序会有什么样的执⾏结果，程序启动的时候就会输出如下⼀⾏：                    
```
[ '0a', 0b' ]
```

接着，1秒钟之后，程序接着会输出下⾯两⾏：
```
[ '1a', '0b' ]
[ '1a', '1b' ]
```

然后，又过了1秒钟，程序又会输出下⾯两⾏：
```
[ '2a', '1b' ]
[ '2a', '2b' ]
```

程序的输出不会结束，整个数据管道都由original$驱动，⽽original$每⼀秒钟只产⽣⼀个数据，
但是在combineLatest之后却产⽣了两个数据。

直观上来说，当original$吐出数据1的时候，source1$会吐出1a，
source2$会吐出1b，那么result$就会产⽣这样⼀个输出:                  
```
[ '1a', '1b' ]
```

这种现象称为⼩缺陷（glitch），指的是combineLatest这样的操作符输
出的不⼀致情况，glitch发⽣是因为多个上游Observable“同时”吐出⼀个数
据，当然，并不是真正的“同时”，⼏个事件之间可能会间隔⼏纳秒的时
间，但是因为它们是由同⼀个数据源（在上⾯的例⼦中就是original$）引
发的，所以逻辑上算是"同时".

这种glitch现象被认为是RxJS的⼀个缺陷，函数响应式编程的原教旨主
义由此认定RxJS不能算是真正的函数响应式编程.

如果想要有上⾯那样纯正的
输出，我们只不过⽤错了操作符，这就需要引⼊RxJS中combineLatest的另
⼀个兄弟`withLatestFrom`。


**combineLatest: 03、其他例子**

combineLatest - 组合3个定时发送:                   
```typescript
import { combineLatest, timer } from 'rxjs';

const timerOne$ = timer(1000, 4000);
const timerTwo$ = timer(2000, 4000);
const timerThree$ = timer(3000, 4000);

const combined$ = combineLatest(timerOne$, timerTwo$, timerThree$);

combined$.subscribe(latestValues => {
  const [one, two, three] = latestValues;

  console.log(`
    timer one latest: ${one};
    timer two latest: ${two};
    timer three latest: ${three};
  `);
});
```
结果:                 
```
timer one latest: 0;
timer two latest: 0;
timer three latest: 0;


timer one latest: 1;
timer two latest: 0;
timer three latest: 0;


timer one latest: 1;
timer two latest: 1;
timer three latest: 0;


timer one latest: 1;
timer two latest: 1;
timer three latest: 1;


timer one latest: 2;
timer two latest: 1;
timer three latest: 1;


timer one latest: 2;
timer two latest: 2;
timer three latest: 1;


timer one latest: 2;
timer two latest: 2;
timer three latest: 2;
............
```
