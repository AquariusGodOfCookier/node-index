## 转换数据流


### map
map这个操作符可以映射⼀段时间上异步产⽣
的数据。因为RxJS的数据处理⽅式是“推”，每当上游推下来⼀个数据，
map就把这个数据作为参数传给map的参数函数，然后再把函数执⾏的返回
值推给下游

map除了必须要有的函数参数project，还有⼀个可选参数
thisArg，⽤于指定函数project执⾏时的this值，下⾯是⽰例代码

```typescript
import { of } from 'rxjs';
import { map } from 'rxjs/operators';

const source$ = of(3, 1, 4);

// 这个地方必须要用 function， 要不然拿不到this
const mapFunc = function(value, index) {
  return `${value} ${this.separator} ${index}`;
};
const context = { separator: ': ' };
const result$ = source$.pipe(
  map(mapFunc, context),
);

result$.subscribe(value => console.log(value));
/*
结果：
3 :  0
1 :  1
4 :  2
* */
```

其实没有必要写成上面那样， 没有啥意义
```typescript
import { of } from 'rxjs';
import { map } from 'rxjs/operators';

const source$ = of(3, 1, 4);
const context = { separator: ': ' };
const mapFunc = (separator: string) => (value, index) => `${value} ${separator} ${index}`;
const result$ = source$.pipe(
  map(mapFunc(context.separator)),
);

result$.subscribe(value => console.log(value));
/*
3 :  0
1 :  1
4 :  2
* */
```


### maoTo
mapTo这个函数完全可以⽤map来实现，如下所⽰：
```typescript
Observable.prototype.mapTo = function (value) {
  return this.map(x => value);
};
```

### pluck
pluck就是把上游数据中特定字段
的值“拔”出来，所以pluck的参数就是字段的名字，⽰例代码如下：

```typescript

```
