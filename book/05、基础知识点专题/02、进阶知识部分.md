## 进阶知识部分

### <div id="class02-01">01、渲染机制</div>

什么是DOCTYPE以及作用、浏览器渲染过程、重排Reflow、重绘Repaint、布局Layout

#### DOCTYPE:
DTD文档类型定义：是一些列的语法规则，用来定义XML或者(X)HTML的文档类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器的模式。                    
DOCTYPE是申明文档类型和DTD规范的，一个主要的用途就是文件的合法性验证。如果文档代码不合法，那么浏览器解析时候会出一些差错的。告诉浏览器下面是什么文档类型                       
html5:<!DOCTYPE html>               
html4：严格模式-包含所有html元素和属性，不包含展示型的和弃用的元素(比如font)                  
宽松模式-XXXXXXXXXXXXXXXXX,包含展示型的和弃用的元素                 

#### 浏览器渲染过程
Firefox、Chrome和Safari是基于两种渲染引擎构建的，**Firefox使用Geoko——Mozilla自主研发的渲染引擎，Safari和Chrome都使用webkit。**

![02_01](./img/02_01.png)

**几个基本概念：**                     
**DOM Tree**：浏览器将HTML解析成树形的数据结构。                
**CSS Rule Tree**：浏览器将CSS解析成树形的数据结构。                    
**Render Tree**: DOM和CSSOM合并后生成Render Tree。                     
**layout**: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。                           
**painting**: 按照算出来的规则，通过显卡，把内容画到屏幕上。                       
**reflow（回流/重排）**：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。
reflow 会从 `<html>` 这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。
现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，
都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，
都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。
**repaint（重绘）**：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。

**渲染过程：**                   
尽管Webkit与Gecko使用略微不同的术语，这个过程还是基本相同的，如下：                                   
1. 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。                                            
2. 将CSS解析成 CSS Rule Tree 。                              
3. 根据DOM树和CSS DOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像Header或display:none的东西就没必要放在渲染树中了。                        
4. 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为layout，顾名思义就是计算出每个节点在屏幕中的位置。                      
5. 再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。                      

注意：上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。
它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

**触发Reflow:**                                  
当增加、删除、修改DOM节点是，会导致Reflow和Repaint;                  
移动DOM 的位置，或者搞个动画的时候                 
修改CSS样式的时候                  
当Resize窗口的时候，或者滚动的时候（有可能）                   
当修改页面默认字体的时候                    

**触发Repaint:**                  
改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。                   
触发条件：               
DOM 改动              
CSS 改动                  

对于Reflow和Repaint最好的做法就是，当页面元素改变的时候，最好是一次性添加或者修改节点，多次添加或者修改。


### <div id="class02-02">02、JS运行机制</div>
示例1：                
```javascript
console.log(1);
setTimeout(function(){
    console.log(2)
},0);
console.log(3);
```
运行结果：1,3,2//原因setTimeout是异步任务，console.log()是同步任务

概念：                 
JS是单线程的，同一时间只能做一件事情                  
任务队列：优先处理同步任务，最后才执行异步队列                 
    同步任务：               
    异步任务：               

示例2：
```javascript
console.log('A');
while (true) {

}
console.log('B')
```
这个输出为A。因为都是同步队列任务，while哪里是一个死循环

示例3：
```javascript
console.log('A');
setTimeout(function(){
    console.log('B')
},0)
while (true) {

}
```
依然只输出了A。原因是在同步任务执行完之前，任何异步队列都是不会被响应的。

示例4：
```javascript
for(var i =0 ;i<4;i++){
    setTimeout(function(){
        console.log(i)
    },1000)
}
```
输出为4个4，for循环是同步任务；
异步队列执行时间：setTimeout是有一个时间，到了时间，才会把语句放在异步队列中去；
异步队列的放入时间和执行时间：执行时间是同步任务执行完了就会执行异步任务，但是异步队列放入时间，
如果是settimeout的话，要等时间到了，才把具体执行语句放入for循环中去。

但是有一种特殊的情况：
```javascript
for(let i =0 ;i<4;i++){
    setTimeout(function(){
        console.log(i)
    },1000)
}
```
这样的话，就是输出的标准的1,2,3,4了。

#### Event Loop:                     
运行栈是执行同步任务的，当执行同步任务的时候发现有异步任务，就会有一个timmer模块来把异步任务拿走，拿走之后也不是立马放入任务队列，
当同步任务执行完了之后，才会把异步任务放在任务队列中，其中settimeout是一个特殊的情况，只有当settimeout的时间到了之后，
浏览器才会把时间放到队列中去，浏览器最小的延时时间之前是10毫秒，现在是4毫秒。只有等时间到了，timmer模块才会把时间放在队列中去。

什么时候开启异步任务：setTimeout、setInterval、DOM事件、ES6的Promise;                        


### <div id="class02-03">03、提升页面性能的方法</div>
资源压缩合并、减少HTTP请求                     
非核心代码异步加载->异步加载的方式->异步加载的区别                         
利用浏览器缓存->缓存的分类->缓存的原理（这是最重要的一部分）                            
使用CND；                  
预解析NDS：                         
<mate http-equiv="x-dns-prefetch-control" content="on">                             
<link rel="dns-prefetch" href="//host_name_to_prefetch.com">                                    

#### 异步加载：
异步加载方式：动态脚本加载(创建动态script节点)、**defer、async**                     
异步加载的区别：                                
1）、defer是在html解析完成之后才会执行，如果是多个，按照加载的顺序依次执行                          
2）、async是在加载完成之后立即执行，如果是多个，那么执行顺序和加载顺序无关                            

**defer**是html4.0中定义的，该属性使得浏览器能延迟脚本的执行，等文档完成解析完成后会按照他们在文档出现顺序再去下载解析。
也就是说defer属性的<script>就类似于将<script>放在body的效果。

**async**是HTML5新增的属性，IE10和浏览器都是支持该属性的。该属性的作用是让脚本能异步加载，也就是说当浏览器遇到async属性的<script>时浏览器加载css一样是异步加载的。

对于这个问题的具体研究还可以看这一篇文章： [defer、async属性以及JS异步加载并执行解决方案](https://blog.csdn.net/q121516340/article/details/51436314)


#### 页面缓存：
分类：强缓存、协商缓存                     

**强缓存**：本地有这个东西，直接就拿过来用，不用向服务器重新请求资源了；                          
http头：                                  
Expires:时间（绝对时间，下发的是服务器的时间）                           
Cache-Control:max-age=3600;//单位秒，客户端相对时间（相对时间）-以这个时间为准                          

**协商缓存**：本地有这个东西之后，不确定到底用不用，所以要想服务器确认一下；                        
Last-Modified：上次修改时间                    
If-Modified-Since:这个是我想服务器请求的时间                 
Etag:哈希值（判断资源是否有修改）                     
If-None-Match:（判断资源是否可以用）                       


### <div id="class02-04">04、错误监控<div>
**错误分类**：即时运行错误（代码错误）、资源加载错误

#### 错误的捕获方式：
**即时运行错误:** 
try...catch                     	
window.onerror                     
 
**资源加载错误:**                                   
1)、object.onerror	                
2)、performance.getEntries()                     
3)、Error事件捕获                    
performance.getEntries()这个是可以获取到所有的家已经加载的资源                                

Error事件捕获使用方式:
```javascript
window.addEventListener('error',function(e){
    console.log('捕获',e)
},true)
```

跨域是可以捕获的:                            
1）、在script标签添加crossorigin属性                              
2)、在js响应头添加Access-Control-Allow-Origin:*;           

           
上报错误：ajax通信方式上报、通过Image对象上报,非常简单                    
(new Image()).src='http://baidu.com/test/sdflijsd?=sdlfkj';                         












