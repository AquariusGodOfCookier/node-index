## 进阶知识部分

### <div id="class02-01">01、渲染机制</div>

什么是DOCTYPE以及作用、浏览器渲染过程、重排Reflow、重绘Repaint、布局Layout

#### DOCTYPE:
DTD文档类型定义：是一些列的语法规则，用来定义XML或者(X)HTML的文档类型。浏览器会使用它来判断文档类型，决定使用何种协议来解析，以及切换浏览器的模式。                    
DOCTYPE是申明文档类型和DTD规范的，一个主要的用途就是文件的合法性验证。如果文档代码不合法，那么浏览器解析时候会出一些差错的。告诉浏览器下面是什么文档类型                       
html5:<!DOCTYPE html>               
html4：严格模式-包含所有html元素和属性，不包含展示型的和弃用的元素(比如font)                  
宽松模式-XXXXXXXXXXXXXXXXX,包含展示型的和弃用的元素                 

#### 浏览器渲染过程
Firefox、Chrome和Safari是基于两种渲染引擎构建的，**Firefox使用Geoko——Mozilla自主研发的渲染引擎，Safari和Chrome都使用webkit。**

![02_01](./img/02_01.png)

**几个基本概念：**                     
**DOM Tree**：浏览器将HTML解析成树形的数据结构。                
**CSS Rule Tree**：浏览器将CSS解析成树形的数据结构。                    
**Render Tree**: DOM和CSSOM合并后生成Render Tree。                     
**layout**: 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系，从而去计算出每个节点在屏幕中的位置。                           
**painting**: 按照算出来的规则，通过显卡，把内容画到屏幕上。                       
**reflow（回流/重排）**：当浏览器发现某个部分发生了点变化影响了布局，需要倒回去重新渲染，内行称这个回退的过程叫 reflow。
reflow 会从 `<html>` 这个root frame开始递归往下，依次计算所有的结点几何尺寸和位置。reflow 几乎是无法避免的。
现在界面上流行的一些效果，比如树状目录的折叠、展开（实质上是元素的显 示与隐藏）等，
都将引起浏览器的 reflow。鼠标滑过、点击……只要这些行为引起了页面上某些元素的占位面积、定位方式、边距等属性的变化，
都会引起它内部、周围甚至整个页面的重新渲 染。通常我们都无法预估浏览器到底会 reflow 哪一部分的代码，它们都彼此相互影响着。
**repaint（重绘）**：改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。

**渲染过程：**                   
尽管Webkit与Gecko使用略微不同的术语，这个过程还是基本相同的，如下：                                   
1. 浏览器会将HTML解析成一个DOM树，DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。                                            
2. 将CSS解析成 CSS Rule Tree 。                              
3. 根据DOM树和CSS DOM来构造 Rendering Tree。注意：Rendering Tree 渲染树并不等同于 DOM 树，因为一些像Header或display:none的东西就没必要放在渲染树中了。                        
4. 有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为layout，顾名思义就是计算出每个节点在屏幕中的位置。                      
5. 再下一步就是绘制，即遍历render树，并使用UI后端层绘制每个节点。                      

注意：上述这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html都解析完成之后再去构建和布局render树。
它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。

**触发Reflow:**                                  
当增加、删除、修改DOM节点是，会导致Reflow和Repaint;                  
移动DOM 的位置，或者搞个动画的时候                 
修改CSS样式的时候                  
当Resize窗口的时候，或者滚动的时候（有可能）                   
当修改页面默认字体的时候                    

**触发Repaint:**                  
改变某个元素的背景色、文字颜色、边框颜色等等不影响它周围或内部布局的属性时，屏幕的一部分要重画，但是元素的几何尺寸没有变。                   
触发条件：               
DOM 改动              
CSS 改动                  

对于Reflow和Repaint最好的做法就是，当页面元素改变的时候，最好是一次性添加或者修改节点，多次添加或者修改。


### <div id="class02-02">02、JS运行机制</div>
示例1：                
```javascript
console.log(1);
setTimeout(function(){
    console.log(2)
},0);
console.log(3);
```
运行结果：1,3,2//原因setTimeout是异步任务，console.log()是同步任务

概念：                 
JS是单线程的，同一时间只能做一件事情                  
任务队列：优先处理同步任务，最后才执行异步队列                 
    同步任务：               
    异步任务：               

示例2：
```javascript
console.log('A');
while (true) {

}
console.log('B')
```
这个输出为A。因为都是同步队列任务，while哪里是一个死循环

示例3：
```javascript
console.log('A');
setTimeout(function(){
    console.log('B')
},0)
while (true) {

}
```
依然只输出了A。原因是在同步任务执行完之前，任何异步队列都是不会被响应的。

示例4：
```javascript
for(var i =0 ;i<4;i++){
    setTimeout(function(){
        console.log(i)
    },1000)
}
```
输出为4个4，for循环是同步任务；
异步队列执行时间：setTimeout是有一个时间，到了时间，才会把语句放在异步队列中去；
异步队列的放入时间和执行时间：执行时间是同步任务执行完了就会执行异步任务，但是异步队列放入时间，
如果是settimeout的话，要等时间到了，才把具体执行语句放入for循环中去。

但是有一种特殊的情况：
```javascript
for(let i =0 ;i<4;i++){
    setTimeout(function(){
        console.log(i)
    },1000)
}
```
这样的话，就是输出的标准的1,2,3,4了。

#### Event Loop:                     
运行栈是执行同步任务的，当执行同步任务的时候发现有异步任务，就会有一个timmer模块来把异步任务拿走，拿走之后也不是立马放入任务队列，
当同步任务执行完了之后，才会把异步任务放在任务队列中，其中settimeout是一个特殊的情况，只有当settimeout的时间到了之后，
浏览器才会把时间放到队列中去，浏览器最小的延时时间之前是10毫秒，现在是4毫秒。只有等时间到了，timmer模块才会把时间放在队列中去。

什么时候开启异步任务：setTimeout、setInterval、DOM事件、ES6的Promise;                        


### <div id="class02-03">03、提升页面性能的方法</div>
资源压缩合并、减少HTTP请求                     
非核心代码异步加载->异步加载的方式->异步加载的区别                         
利用浏览器缓存->缓存的分类->缓存的原理（这是最重要的一部分）                            
使用CND；                  
预解析NDS：                         
<mate http-equiv="x-dns-prefetch-control" content="on">                             
<link rel="dns-prefetch" href="//host_name_to_prefetch.com">                                    

#### 异步加载：
异步加载方式：动态脚本加载(创建动态script节点)、**defer、async**                     
异步加载的区别：                                
1）、defer是在html解析完成之后才会执行，如果是多个，按照加载的顺序依次执行                          
2）、async是在加载完成之后立即执行，如果是多个，那么执行顺序和加载顺序无关                            

**defer**是html4.0中定义的，该属性使得浏览器能延迟脚本的执行，等文档完成解析完成后会按照他们在文档出现顺序再去下载解析。
也就是说defer属性的<script>就类似于将<script>放在body的效果。

**async**是HTML5新增的属性，IE10和浏览器都是支持该属性的。该属性的作用是让脚本能异步加载，也就是说当浏览器遇到async属性的<script>时浏览器加载css一样是异步加载的。

对于这个问题的具体研究还可以看这一篇文章： [defer、async属性以及JS异步加载并执行解决方案](https://blog.csdn.net/q121516340/article/details/51436314)


#### 页面缓存：
分类：强缓存、协商缓存                     

**强缓存**：本地有这个东西，直接就拿过来用，不用向服务器重新请求资源了；                          
http头：                                  
Expires:时间（绝对时间，下发的是服务器的时间）                           
Cache-Control:max-age=3600;//单位秒，客户端相对时间（相对时间）-以这个时间为准                          

**协商缓存**：本地有这个东西之后，不确定到底用不用，所以要想服务器确认一下；                        
Last-Modified：上次修改时间                    
If-Modified-Since:这个是我想服务器请求的时间                 
Etag:哈希值（判断资源是否有修改）                     
If-None-Match:（判断资源是否可以用）                       


### <div id="class02-04">04、错误监控<div>
**错误分类**：即时运行错误（代码错误）、资源加载错误

#### 错误的捕获方式：
**即时运行错误:** 
try...catch                     	
window.onerror                     
 
**资源加载错误:**                                   
1)、object.onerror	                
2)、performance.getEntries()                     
3)、Error事件捕获                    
performance.getEntries()这个是可以获取到所有的家已经加载的资源                                

Error事件捕获使用方式:
```javascript
window.addEventListener('error',function(e){
    console.log('捕获',e)
},true)
```

跨域是可以捕获的:                            
1）、在script标签添加crossorigin属性                              
2)、在js响应头添加Access-Control-Allow-Origin:*;           

           
上报错误：ajax通信方式上报、通过Image对象上报,非常简单                    
(new Image()).src='http://baidu.com/test/sdflijsd?=sdlfkj';                         


### <div id="class02-05">05、TCP和UDP的区别</div>
HTTPS：（全称：Hypertext Transfer Protocol over Secure Socket Layer），是以安全为目标的HTTP通道，简单讲是HTTP的安全版。
即HTTP下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。

优点： **协议较成熟，应用广泛、基于TCP/IP，拥有TCP优点、研发成本很低，开发快速、开源软件较多**，nginx,apache,tomact等
缺点： **无状态、无连接**、只有PULL模式，不支持PUSH、数据报文较大
特性： **基于TCP/IP应用层协议、无状态，无连接**、支持C/S模式、适用于文本传输

#### TCP
TCP：（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。
一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂。
建立一个连接需要三次握手，而终止一个连接要经过四次握手，这是由TCP的半关闭（half-close）造成的。

优点： **可靠性 、全双工协议、开源支持多、应用较广泛、面向连接**、研发成本低、报文内容不限制（IP层自动分包，重传，不大于1452bytes）                      
缺点： 操作系统：较耗内存，支持连接数有限、设计：协议较复杂，自定义应用层协议、网络：网络差情况下延迟较高、传输：效率低于UDP协议特性： 面向连接、可靠性、全双工协议、基于IP层、OSI参考模型位于传输层、适用于二进制传输

**三次握手 与 四次挥手**
当客户端和服务器通过三次握手建立了TCP连接以后，当数据传送完毕，肯定是要断开TCP连接的啊。那对于TCP的断开连接，这里就有了神秘的“四次挥手”。              
1.第一次挥手：主机1(可以使客户端，也可以是服务器端)，设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段;此时，主机1进入FIN_WAIT_1状态;这表示主机1没有数据要发送给主机2了;                    
2.第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1;主机1进入FIN_WAIT_2状态;主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了;               
3.第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态;                 
4.第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态;主机2收到主机1的ACK报文段以后，就关闭连接;此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。                 
至此，TCP的四次挥手就这么愉快的完成了。        

               
#### UDP                
UDP：UDP是一个无连接协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，
并尽可能快地把它扔到网络上。在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；
在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。                               
优点： 操作系统：并发高，内存消耗较低、传输：效率高，网络延迟低、传输模型简单，研发成本低                           
缺点： 协议不可靠、单向协议、开源支持少、报文内容有限，不能大于1464bytes、设计：协议设计较复杂、网络：网络差，而且丢数据报文                             
特性：无连接，不可靠，基于IP协议层，OSI参考模型位于传输层，最大努力交付，适用于二进制传输                             


### <div id="class02-06">06、express middleware</div>
express middleware原理：责任链模式

```javascript
function App() {
    if (!(this instanceof App))
        return new App();
    this.init();
}

App.prototype = {
    constructor: App,
    init: function () {
        this.request = { //模拟的request
            requestLine: 'POST /iven_ HTTP/1.1',
            headers: 'Host:www.baidu.com\r\nCookie:BAIDUID=E063E9B2690116090FE24E01ACDDF4AD:FG=1;BD_HOME=0',
            requestBody: 'key1=value1&key2=value2&key3=value3',
        };
        this.response = {}; //模拟的response
        this.chain = []; //存放中间件的一个数组
        this.index = 0; //当前执行的中间件在chain中的位置
    },
    use: function (handle) { //这里默认 handle 是函数，并且这里不做判断
        this.chain.push(handle);
    },
    next: function () { //当调用next时执行index所指向的中间件
        if (this.index >= this.chain.length)
            return;
        let middleware = this.chain[this.index];
        this.index++;
        middleware(this.request, this.response, this.next.bind(this));
    },
};
```

### <div id="class01-07">07、vue双向绑定原理</div>
[双向绑定原理研究与简单的双向绑定实现](../../18年/3月/06、双向绑定核心代码)








