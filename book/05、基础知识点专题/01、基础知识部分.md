## 基础知识部分

### <div id="class01-01">01、高度已知：左右各300px,中间自适应</div>     

浮动、绝对定位、flexBox（display：flex）、table标签 、网格布局（display:Grid）、display: table-cell;           
延伸：每个解决方案的优缺点，之间的比较；如果去掉高度已知，什么方案不适用了；兼容性，业务中最实用的；              
浮动：需要清除浮动，兼容性比较好；           
绝对定位：快捷、因为已经脱离文档流了，所以子元素都也要脱离文档流，可实用性非常差；           
flex:就是为了以上连个布局的不足的；            
display:table:兼容性非常好，三栏布局，如果某一个高度超出的时候，另外另个也都是会一起增高的；           
网格布局：新技术；           

### <div id="class01-02">02、上下居中方案</div>

### <div id="class01-03">03、css盒模型</div>                 

**标准和模型+IE盒模型：**        
区别：标准模型的宽高是不计算padding和border的，IE是需要计算的      
css如何设置这两种模型：       
默认是： `box-sizing:content-box;box-sizing:border-box;`    
JS如何设置获取盒模型对应的宽高：       

```javascript
dom.style.width/height;     
dom.currentStyle.width/height;      
window.getComputedStyle(dom).width/height;
```      

**解释边距重叠：**         
BFC边距重叠的解决方案        

### <div id="class01-04">04、DOM事件类</div>     
DOM事件级别、DOM事件模型、DOM事件流、DOM事件捕获的具体流程、Event对象的常见应用、自动以事件

**事件级别:**  
DOM0:element.onclick=function(){};
DOM2:elemeng.addEventListener("click",function(){},false);//但三个指定捕获或者冒泡
DOM3:elemeng.addEventListener("keyup",function(){},false);//但三个指定捕获或者冒泡

**事件模型：** 捕获（从上到下）、冒泡（从下到上）；

**事件流：** 用户和浏览器做交互的过程中，事件的传递，比如点击左键，怎么传递到页面上的。
捕获->目标阶段->冒泡

**DOM事件具体流程：**  
window->document->html->body->.....普通html一步一步下传...->目标元素

**Event对象：**  
event.keyCode;  
event.preventDefault();//阻止默认时间     
event.stopPropatation();//阻止冒泡      
event.stopImmediatePropagation();//处理事件响应优先级        
event.currentTarget();//当前绑定的事件     
event.target();//获取当前点击元素对象     

**自定义事件：**
```javascript
    var eve=new Event('custome');
    ev.addEventListener('custome',function(){//ev就是一个简单的元素对象
    console.log('custome');
    });
    ev.dispatchEvent(eve);//触发事件
    
    //需要制定参数的自定义事件    CustomeEvent
    var eve = new CustomeEvent('custome',obj);
```
    
### 5、Http协议类：            
**特点：** 简单快速，灵活、无连接、无状态   
每一个资源对应一个URI，请求只要输入资源地址uri就可以了；     
在每一个http头部协议中都有一个数据类型，通过一个http协议就可以完成不同类型数据的传输；     
链接一次就会断开；       
每一次链接不会记住链接状态的，服务器不区分两次链接的身份；       

**http报文组成部分，建立在TCP之上的:**             
    请求报文：请求行、请求头、空行、请求体     
    请求行：HTTP请求方法、页面地址、协议版本等         
    请求头：key,value值，告诉服务端我要什么内容、要什么数据类型                      
    空行：分割请求头和请求体的，遇到空行，服务器就知道，请求头结束了，接下来是请求体了           
    请求体：就是给服务端的一些入参数据；          
    我所了解的请求体有两种格式，Content-Type: application/x-www-form-urlencoded  和  payload  和 json             

**响应报文：** 状态行、响应头、空行、响应体     
状态行：协议版本  状态码   状态      
其他的一样的      

**响应报文：** 状态行、响应头、空行、响应体
状态行：协议版本  状态码   状态
其他的一样的

**HTTP方法：** GET请求资源、post传输资源、put更新资源、delete删除资源、head获取报文首部           
get和post区别：     
get只能url 编码、post支持多种编码方式            
get在传输参数有长度限制的，而post是没有长度限制的        
get通过url传递，post放在request body中      
get不安全，post是一种安全的传输协议方式     
get会把参数保存到浏览器记录里，而post中的参数不会保存          
get 会被浏览器缓存         

**http状态码：**        
**1.XX**:指示信息-表示请求已经接受，继续处理         
**2.XX:成功**         
    200：请求成功            
    206：客户端发送一个range头的get请求，服务器完成了他         
**3.XX：重定向**        
    301：请求的页面转移到新的url;      
    302:临时转移到新的url          
    304：客户端缓存的文件并发出了一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用         
**4.XX：客户端错误**             
    400：语法错误        
    401：请求未授权       
    403：请求禁止访问      
    404：请求资源不存在     
**5.XX：服务端错误**     
    500：服务器发生不可预期的错误        
    503：服务器请求未完成        
    
**HTTP持久链接：**                       
http采用的是 "请求-应答" 模式                         
当使用keep-Alive 模式（又称持久链接、链接重用）时、http1.1版本才支持的                        
    Connection: keep-alive                      
            
**管线化：**                                
持久链接下：链接传递消息类似于请求1->响应1->请求2->响应2->请求3->响应3                             
管线化：请求1-》请求2-》请求3-》响应1-》响应2-》响应3                            
需要通过持久链接完成，所以仅HTTP1.1版本支持                       
只有get和head请求支持管线化，post请求是有所限制的          


### <div id="class01-06">原型链</div>
内容：                 
创建对象的几种方式、原型、构造函数、实例、原型链、instanceof原理、new 运算符

#### 创建对象的几种方法
```javascript
// 面向字面量
var o1={name:'01'};
var o11=new Object({name:'o11'});

// 使用显示的构造函数：
var M=function(){this.name='02'};
var o2=new M();

// 通过Object.create()创建
var P={name:'o3'};
var o3=Object.create(P)
```


#### 原型、构造函、实例、原型链：                             
![01_01](./img/01_01.png)
1、基础                  
构造函数可以通过new来生成一个实例、构造函数也是函数；                
函数都有一个prototype属性，这个就是原型对象；         
原型对象可以通过构造器constructor来指向它的构造函数；             
实例的__proto__属性，指向的是其构造函数的原型对象；                          


原型链：从一个实例对象，向上找构造这个实例相关联的对象，相关联的对象又向上找，找到创造它的一个实例对象，
一直到Object.prototype截止。原型链是通过prototype和__proto__向上找的。构造函数通过prototype创建了很多方法，
被其所有实例所公用，存放在原型对象上；                      

例子：
```javascript
var M=function(name){this.name=name};
var o3=new M('o3');
```

当我们需要扩展实例的时候，我们可以对构造函数添加方法，但是这样会创建每一个实例都拷贝一份它自己的添加的方法，
占用内存，而且也没有必要，这个时候就可以新添加的方法写进原型里面去，添加到原型链中去，
在实例的原型链中我们可以在原型对象上找到添加的方法；

```javascript
var M=function(name){this.name=name};
var o3=new M('o3');
M.prototype.say=function(){
Console.log('say hi');
};
var o5=new M('o5');
```
通过这种方式o3和o5都有say方法；原型链的优势是原型对象的方法是被所有实例共有的；

当访问一个实例方法的时候，首先在实例本身找这个方法，如果没有找到就会到其构建函数的原型对象去找，如果还是没有找到，
那么它会继续通过原型链在原型对象的更上一级查找，一直到object.prototype;

一定要记住只有函数才有proptotype,对象是没有的；

只有实例对象又__proto__ , 因为函数也是对象，所以函数也有__proto__ , 但是和实例对象的__proto__是有区别的，函数的__proto__是function这个对象的构造实例；


2、instanceof原理

实例对象上面有一个__proto__ ，这个是引用的它构造函数的原型对象；

instanceof是用来判断实例是不是由某个构造函数实例化出来的对象，其原理是判断实例对象是否指向构造函数的原型；
只要是在原型链上的函数，都会被instanceof看做是实例对象的一个构造函数，所以都会返回true;

```
m1.__proto__===m1.prototype;返回true
m1.prototype.__proto===Object.prototype;返回true

o3.__proto__.constructor===Object;//返回false
所以我们判断一个实例对象的构造函数，用constructor;
```

3、new 运算符		后面跟着的是一个构造函数

一个新对象被创建。它继承自foo.prototype->                            
构造函数foo会被执行，执行的时候，相应的传参会被传入，同时上下文（this）会被指定为这个新实例。	new foo等同于new foo(),只能在不传递任何参数的情况->                     
如果构造函数返回了一个‘对象’，那么这个对象会取代整个new 出来的结果。如果构造函数没有返回值，	那么new出来的结果为步骤1创建的对象

4、Object.create()；创建的实例对象是指向的对象原型，实例对象本身是不具备创建对象的属性和方法的，是通过原型链来链接的。


### <div id="class01-07">07、面向对象</div>

#### 类与实例：类的申明、生成实例

类与实例：
```javascript
/*类的申明*/
function Animal(){
    //通过this来表明这是一个构造函数
    this.name='name';
}

//ES6的申明方式
class Animal2{
    constructor(){//构造函数
        this.name=name
    }
}
```

实例化：
```javascript
/*实例化*/
console.log(new Animal(),new Animal2())
```

#### 继承：                    

**7.1、借助构造函数实现继承**

call和apply改变的是JS运行的上下文:             
```javascript
/*借助构造函数实现继承*/
function Parent(name) {
    this.name = name;
    this.getName = function () {
        console.log(this.name);
    }
}

function Child(name) {
    Parent.call(this, name);
    this.type = 'child1'
}

let child = new Child('yanle');
child.getName();
console.log(child.type);
```
父类的this指向到了子类上面去，改变了实例化的this 指向，导致了父类执行的属性和方法，都会挂在到	子类实例上去；                     
缺点：父类原型链上的东西并没有被继承；


**7.2、通过原型链实现继承**                   
```javascript
/*通过原型链实现继承*/
function Parent2(){
    this.name='parent2'
}

function Child2(){
    this.type='child2'
}

Child2.prototype=new Parent2();
console.log(new Child2());
```

Child2.prototype是Child2构造函数的一个属性，这个时候prototype被赋值了parent2的一个实例，实例化了新的对象Child2()的时候，
会有一个__proto__属性，这个属性就等于起构造函数的原型对象，但是原型对象被赋值为了parent2的一个实例，
所以new Child2的原型链就会一直向上找parent2的原型

var s1=new Child2();                
var s2=new Child2();                    
s1.__proto__===s2.__proto__;//返回true                        

缺点：通过子类构造函数实例化了两个对象，当一个实例对象改变其构造函数的属性的时候，
那么另外一个实例对象上的属性也会跟着改变（期望的是两个对象是隔离的赛）；原因是构造函数的原型对象是公用的；


**7.3、组合方式**
```javascript
/*组合方式*/
function Parent3(){
    this.name='parent3';
    this.arr=[1,2,3];
}

function Child3(){
    Parent3.call(this);
    this.type='child';
}

Child3.prototype=new Parent3();
var s3=new Child3();
var s4=new Child3();
s3.arr.push(4);
console.log(s3,s4);
```

优点:这是最通用的使用方法，集合了上面构造函数继承，原型链继承两种的优点。                      
缺点:父类的构造函数执行了2次，这是没有必要的，                            
constructor指向了parent了


**7.4、组合继承的优化1**
```javascript
/*组合继承的优化1*/
function Parent4(){
    this.name='parent3';
    this.arr=[1,2,3];
}

function Child4(){
    Parent4.call(this);
    this.type='child5';
}

Child4.prototype=Parent4.prototype;
var s5=new Child4();
var s6=new Child4()
```

缺点：s5 instaceof child4//true, s5 instanceof Parent4//true                                
我们无法区分一个实例对象是由其构造函数实例化，还是又其构造函数的父类实例化的                              
s5.constructor  指向的是Parent4;//原因是子类原型对象的constructor 被赋值为了父类原型对象的	constructor,所以我们使用constructor的时候，肯定是指向父类的                           
Child3.constructor 也有这种情况                               

**7.5、组合继承的优化2**
```javascript
function Parent5() {
    this.name = 'parent5';
    this.play = [1, 2, 3];
}

function Child5() {
    Parent5.call(this);
    this.type = 'child5'
}

Child5.prototype = Object.create(Parent5.prototype);
//这个时候虽然隔离了，但是constructor还是只想的Parent5的，因为constructor会一直向上找
Child5.prototype.constructor=Child5;

var s7=new Child5();
console.log(s7 instanceof Child5,s7 instanceof Parent5);
console.log(s7.constructor);
```

通过Object.create来创建原型中间对象，那么这么来的话，chiild5的对象prototype获得的是parent5	父类的原型对象；                    
Object.create创建的对象，原型对象就是参数；                            
    
    
**7.6、ES 中的继承**
后面自信该补充...



### <div id="class01-08">08、通信类</div>

#### 同源策略与限制：
同源策略限制从一个源加载的文档或者脚本如何与来自另一个源的资源进行交互。
这是一个用于隔离潜在恶意文件的关键安全机制。（源：协议、域名、端口；不是一个源的文档资源，是操作不了另外一个源的文档资源的）；
比如：Cookie、LocalStorage和indexDB无法读取、DOM无法获得、ajax无法发送


前后端如何通信：**Ajax(同源通信)、webSocket(不限制同源策略)、CORS(支持跨域，也支持同源)**                  

创建Ajax:工作流程、兼容处理、出发条件、触发顺序                      
示例1：通过promise来创建一个ajax                              
```javascript
var getJSON = function (url) {
    var promise = new Promise(function (resolve, reject) {
        var client = new XMLHttpRequest();
//如果是IE的内核ActiveXObject('Microsoft.XMLHTTP');
        client.open("GET", url);
        client.onreadystatechange = handler;
        client.responseType = "json";
        client.setRequestHeader("Accept", "application/json");
//如果是post请求：client.setRequestHeader('Content-Type','application/X-WWW-form-urlencoded')
        client.send();

        function handler() {
            if (this.readyState !== 4) {
                return;
            }
            if (this.status === 200) {
                resolve(this.response);
            } else {
                reject(new Error(this.statusText));
            }
        };
    });
    return promise;
};

getJSON("/posts.json").then(function (json) {
    console.log('Contents: ' + json);
}, function (error) {
    console.error(' 出错了 ', error);
});
```

示例2：
```javascript
/* 封装一个高级的ajax工具*/
extend = function (dst, obj) {
    for (var i in obj) {
        if (obj.hasOwnProperty(i)) {
            dst[i] = obj[i];
        }
    }
};

json = function (options) {
    var opt = {
        url: '',
        type: 'get',
        data: {},
        success: function () {
        },
        error: function () {
        },
    };
    extend(opt, options);
    if (opt.url) {
        var xhr = XMLHttpRequest
            ? new XMLHttpRequest()
            : new ActiveXObject('Microsoft.XMLHTTP');
        var data = opt.data,
            url = opt.url,
            type = opt.type.toUpperCase(),
            dataArr = [];
        for (var k in data) {
            dataArr.push(k + '=' + data[k]);
        }
        if (type === 'GET') {
            url = url + '?' + dataArr.join('&');
            xhr.open(type, url.replace(/\?$/g, ''), true);
            xhr.send();
        }
        if (type === 'POST') {
            xhr.open(type, url, true);
            xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
            xhr.send(dataArr.join('&'));
        }
        xhr.onload = function () {
            if (xhr.status === 200 || xhr.status === 304) {
                var res;
                if (opt.success && opt.success instanceof Function) {
                    res = xhr.responseText;
                    if (typeof res === 'string') {
                        res = JSON.parse(res);
                        opt.success.call(xhr, res);
                    }
                }
            } else {
                if (opt.error && opt.error instanceof Function) {
                    opt.error.call(xhr, res);
                }
            }
        };
    }
};
```
