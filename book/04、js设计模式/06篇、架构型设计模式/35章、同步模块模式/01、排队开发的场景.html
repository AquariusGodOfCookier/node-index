<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>


<script>
    /*
    * 普通的场景情况
    * 这样写的好处是方便， A工程师把数据和导航元素容器都保存在这里了， 我们可以直接用
    * 缺点： A工程师正在修改导航， 那么BC工程师对导航的新需求就无法执行了。
    * */
    let data = null,
        dom = A('#nav'),
        createNav = function () {
            // A 工程师完成创建导航创建逻辑
            let li  = A('li', dom);
            for (let i = 0, len = data.length; i < len; i++) {
                if(data[i].hasGuide) {
                    $(li[i]).addClass('has-guide')
                }
            }

            // B 工程师加入 完成对导航添加事件需求
            let li = A('li', dom);
            li.on('mouseover', function () {
                // 显示下拉框逻辑
            }).on('mouseout', function () {
                // 隐藏下拉框逻辑
            })
        };

        A.ajax('/data/nav', function () {
            if(res.errorNo === 0) {
                data = res.data;
                createNav();
            }
        });

    /*
    * 模块化开发就是讲复杂的系统分解为高内聚，低耦合的模块。
    * 每个工程师都可以去开发自己的模块实现复杂的系统可控， 可维护， 可扩展。 模块相互之间可以调用
    * 要点： 首先要有一个模块管理器， 管理模块的创建和调度
    * 模块调动： 调用分为两类， 一类同步模块调用的实现， 第二类是一步模块的实现
    * */
    // 闯进模块管理对象F
    class F {
        static define(str, fn) {
            let parts = str.split('.'),
                old = parent = this,
                i = len = 0;                // i 是模块成绩， len是模块层级长度
            // 如果第一个模块是管理模块器， 则移除
            if(parts[0] === 'F') {
                parts = parts.slice(1);
            }
            // 屏蔽对define与module模块
        };
    }
</script>
</body>
</html>