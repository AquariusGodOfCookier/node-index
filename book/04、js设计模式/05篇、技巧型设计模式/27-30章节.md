## <div id="class05">第五篇、技巧型设计模式</div>

### <div id="class05-27">27章、链式模式</div>
描述：                     
通过在对象方法中将对象返回， 实现对同一个对象多个方法的链式调用。简化对该对象的多个方法的多次调用时，对该对象的多次引用。               
最典型的使用就是jQuery

简单的来说， 这种设计模式就是封装一个对象， 然后对象方法处理数据， 数据就放在对象的属性上面， 然后方法返回this指针， 就可以了。

来看一个实际使用的一个实例：               
```js
/*
* sum(1).sum(1,2).sum(3,4).sum(2).sum(2,3,4,5,6,7,8).result()  // 48
* */
class Test {
    constructor() {
        this.resultNumber = 0;
    }
    sum() {
        let args = arguments,
            len = args.length;
        if (len > 0) {
            for (let num of args) {
                this.resultNumber += num;
            }
        }
        return this;
    }
    result() {
        return this.resultNumber;
    }
}
let test = new Test();

let resultNumber = test.sum(1).sum(1, 2).sum(3, 4).sum(2).sum(2, 3, 4, 5, 6, 7, 8).result();
console.log(resultNumber);     // 48
```

其他的示例：                                          
[01、原型式继承存在的问题](./27章、链式模式/01、原型式继承存在的问题.js)                                                    
[02、对于类jQuery链式调用模式的研究](./27章、链式模式/02、对于类jQuery链式调用模式的研究.js)                                                
[03、链式模式的一个实际使用实例](./27章、链式模式/03、链式模式的一个实际使用实例.js)                                                      


### <div id="class05-28">28章、委托模式</div>
#### 描述:                                     
多个对象接受并处理同一个请求， 他们请求委托给另一个对象统一处理请求。                                         
这种设计模式是只针对于浏览器端的来使用的， 至于node没有dom, 所以没有这个特性。                                                                  

#### 实际场景
第一个场景                                                                       
日历模块， 用户点击每个日期格子的时候将格子的背景色变为灰色， 大多数的做法就是把每个日期格子都绑定一个事件， 做法如下：
```js
let ul = document.getElementById('container');
let li = ul.getElementById('li'),
    len = li.length - 1;
for (; len >= 0; len--) {
    li[i].onclick = function () {
        this.style.backgroundColor = 'gery';
    }
}
```

委托模式实际上就是讲事件委托给更高层面上的肤元素去绑定执行。
```js

let ul = document.getElementById('container');
ul.onclick = function (e = window.event) {
    let tar = e.target || e.srcElement;
    if (tar.nodeName.toLowerCase() === 'li') {
        tar.style.color = 'blue';
    }
}
```

第二个场景                                                       
还有一种使用场景： 就是比如我们的dom 是动态添加的， 我们可以把它触发的时间， 暂时委托给父级。 这样的jquery中非常的常见。
```js
$(document).on('click', '#target', function() {
    // 处理逻辑
})
```

第三个场景                                               
委托模式可以解决一些内存泄漏的问题。
```html
<div id="container">
    <button id="btn">dom</button>
</div>

<script>
/*
* 下面一段代码中， g变量中保存了元素绑定的click事件没有清楚， 这个时间就会泄露到内存中去
* 失去了对其的控制
* */
let g = function (id) {
    return document.getElementById(id);
};
g('btn').onclick = function () {
    g('container').innerHTML = '触发了事件'
};

/*
* 利用委托模式解决上面所面临的问题
* */
g('container').onclick = function (e = window.event.srcElement) {
    let target = e && e.target;
    if(target.id === 'btn') {
        g('container').innerHTML = '触发了事件'
    }
}
</script>
```

#### 代码示例
[01、实际场景-点击日期格子变色](./28章、委托模式/01、实际场景-点击日期格子变色.html)                                                
[02、实际场景-处理内存泄漏问题](./28章、委托模式/02、实际场景-处理内存泄漏问题.html)                                                                                    


